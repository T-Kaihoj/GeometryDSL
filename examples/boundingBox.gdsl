// Originally produced by Carl Schultz
// Tested on the 2020-08-14

type Point(x:int, y:int)
type Rectangle(p1: Point, p2: Point)
//INV Rectangle.p1.x < Rectangle.p2.x && Rectangle.p1.y < Rectangle.p2.y

int getX(p: Point)(return p.x)
int getY(p: Point)(return p.y)

bool larger(r1: Rectangle, r2: Rectangle)
(
    return  ((r1.p1.x - r1.p2.x) * (r1.p1.x - r1.p2.x) * (r1.p1.y - r1.p2.y) * (r1.p1.y - r1.p2.y)) >= ((r2.p1.x - r2.p2.x) * (r2.p1.x - r2.p2.x) *(r2.p1.y - r2.p2.y) * (r2.p1.y - r2.p2.y)))

Rectangle largest(R: set)
(
    return choose(r in R,  all(t in R, larger(r, t)))
)

set main()
(
    A: set := {Point(33, 52), Point(73, 69), Point(31, 80), Point(8, 79), Point(53, 70), Point(3, 77), Point(3, 87), Point(18, 29), Point(5, 7)}
    X: set := getX(A)
    Y: set := getY(A)
    P: set := Point(X, Y)
    R: set := Rectangle(P, P)
    R2: set := select(r in R, r.p1.x < r.p2.x && r.p1.y < r.p2.y) //{r in R | r.p1.x < r.p2.x && r.p1.y < r.p2.y | r}
    LR: Rectangle := largest(R2)
    return LR
)
